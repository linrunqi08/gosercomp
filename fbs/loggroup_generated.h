// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_LOGGROUP_LOGGROUP_H_
#define FLATBUFFERS_GENERATED_LOGGROUP_LOGGROUP_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 9,
             "Non-compatible flatbuffers version included");

namespace LogGroup {

struct LogGroup;
struct LogGroupBuilder;

struct LogContent;
struct LogContentBuilder;

struct LogTag;
struct LogTagBuilder;

struct Log;
struct LogBuilder;

struct LogGroup FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LogGroupBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOGS = 4,
    VT_LOGTAG = 6,
    VT_CATEGORY = 8,
    VT_TOPIC = 10,
    VT_SOURCE = 12,
    VT_MACHINEUUID = 14
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<LogGroup::Log>> *logs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<LogGroup::Log>> *>(VT_LOGS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<LogGroup::Log>> *mutable_logs() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<LogGroup::Log>> *>(VT_LOGS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<LogGroup::LogTag>> *logtag() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<LogGroup::LogTag>> *>(VT_LOGTAG);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<LogGroup::LogTag>> *mutable_logtag() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<LogGroup::LogTag>> *>(VT_LOGTAG);
  }
  const ::flatbuffers::String *category() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CATEGORY);
  }
  ::flatbuffers::String *mutable_category() {
    return GetPointer<::flatbuffers::String *>(VT_CATEGORY);
  }
  const ::flatbuffers::String *topic() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TOPIC);
  }
  ::flatbuffers::String *mutable_topic() {
    return GetPointer<::flatbuffers::String *>(VT_TOPIC);
  }
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  ::flatbuffers::String *mutable_source() {
    return GetPointer<::flatbuffers::String *>(VT_SOURCE);
  }
  const ::flatbuffers::String *machineuuid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MACHINEUUID);
  }
  ::flatbuffers::String *mutable_machineuuid() {
    return GetPointer<::flatbuffers::String *>(VT_MACHINEUUID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOGS) &&
           verifier.VerifyVector(logs()) &&
           verifier.VerifyVectorOfTables(logs()) &&
           VerifyOffset(verifier, VT_LOGTAG) &&
           verifier.VerifyVector(logtag()) &&
           verifier.VerifyVectorOfTables(logtag()) &&
           VerifyOffset(verifier, VT_CATEGORY) &&
           verifier.VerifyString(category()) &&
           VerifyOffset(verifier, VT_TOPIC) &&
           verifier.VerifyString(topic()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_MACHINEUUID) &&
           verifier.VerifyString(machineuuid()) &&
           verifier.EndTable();
  }
};

struct LogGroupBuilder {
  typedef LogGroup Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_logs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<LogGroup::Log>>> logs) {
    fbb_.AddOffset(LogGroup::VT_LOGS, logs);
  }
  void add_logtag(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<LogGroup::LogTag>>> logtag) {
    fbb_.AddOffset(LogGroup::VT_LOGTAG, logtag);
  }
  void add_category(::flatbuffers::Offset<::flatbuffers::String> category) {
    fbb_.AddOffset(LogGroup::VT_CATEGORY, category);
  }
  void add_topic(::flatbuffers::Offset<::flatbuffers::String> topic) {
    fbb_.AddOffset(LogGroup::VT_TOPIC, topic);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(LogGroup::VT_SOURCE, source);
  }
  void add_machineuuid(::flatbuffers::Offset<::flatbuffers::String> machineuuid) {
    fbb_.AddOffset(LogGroup::VT_MACHINEUUID, machineuuid);
  }
  explicit LogGroupBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LogGroup> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LogGroup>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LogGroup> CreateLogGroup(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<LogGroup::Log>>> logs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<LogGroup::LogTag>>> logtag = 0,
    ::flatbuffers::Offset<::flatbuffers::String> category = 0,
    ::flatbuffers::Offset<::flatbuffers::String> topic = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    ::flatbuffers::Offset<::flatbuffers::String> machineuuid = 0) {
  LogGroupBuilder builder_(_fbb);
  builder_.add_machineuuid(machineuuid);
  builder_.add_source(source);
  builder_.add_topic(topic);
  builder_.add_category(category);
  builder_.add_logtag(logtag);
  builder_.add_logs(logs);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LogGroup> CreateLogGroupDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<LogGroup::Log>> *logs = nullptr,
    const std::vector<::flatbuffers::Offset<LogGroup::LogTag>> *logtag = nullptr,
    const char *category = nullptr,
    const char *topic = nullptr,
    const char *source = nullptr,
    const char *machineuuid = nullptr) {
  auto logs__ = logs ? _fbb.CreateVector<::flatbuffers::Offset<LogGroup::Log>>(*logs) : 0;
  auto logtag__ = logtag ? _fbb.CreateVector<::flatbuffers::Offset<LogGroup::LogTag>>(*logtag) : 0;
  auto category__ = category ? _fbb.CreateString(category) : 0;
  auto topic__ = topic ? _fbb.CreateString(topic) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto machineuuid__ = machineuuid ? _fbb.CreateString(machineuuid) : 0;
  return LogGroup::CreateLogGroup(
      _fbb,
      logs__,
      logtag__,
      category__,
      topic__,
      source__,
      machineuuid__);
}

struct LogContent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LogContentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  ::flatbuffers::String *mutable_key() {
    return GetPointer<::flatbuffers::String *>(VT_KEY);
  }
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  ::flatbuffers::String *mutable_value() {
    return GetPointer<::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct LogContentBuilder {
  typedef LogContent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(LogContent::VT_KEY, key);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(LogContent::VT_VALUE, value);
  }
  explicit LogContentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LogContent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LogContent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LogContent> CreateLogContent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  LogContentBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LogContent> CreateLogContentDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const char *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return LogGroup::CreateLogContent(
      _fbb,
      key__,
      value__);
}

struct LogTag FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LogTagBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  ::flatbuffers::String *mutable_key() {
    return GetPointer<::flatbuffers::String *>(VT_KEY);
  }
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  ::flatbuffers::String *mutable_value() {
    return GetPointer<::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct LogTagBuilder {
  typedef LogTag Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(LogTag::VT_KEY, key);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(LogTag::VT_VALUE, value);
  }
  explicit LogTagBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LogTag> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LogTag>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LogTag> CreateLogTag(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  LogTagBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LogTag> CreateLogTagDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const char *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return LogGroup::CreateLogTag(
      _fbb,
      key__,
      value__);
}

struct Log FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LogBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_CONTENTS = 6
  };
  int64_t time() const {
    return GetField<int64_t>(VT_TIME, 0);
  }
  bool mutate_time(int64_t _time = 0) {
    return SetField<int64_t>(VT_TIME, _time, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<LogGroup::LogContent>> *contents() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<LogGroup::LogContent>> *>(VT_CONTENTS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<LogGroup::LogContent>> *mutable_contents() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<LogGroup::LogContent>> *>(VT_CONTENTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIME, 8) &&
           VerifyOffset(verifier, VT_CONTENTS) &&
           verifier.VerifyVector(contents()) &&
           verifier.VerifyVectorOfTables(contents()) &&
           verifier.EndTable();
  }
};

struct LogBuilder {
  typedef Log Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_time(int64_t time) {
    fbb_.AddElement<int64_t>(Log::VT_TIME, time, 0);
  }
  void add_contents(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<LogGroup::LogContent>>> contents) {
    fbb_.AddOffset(Log::VT_CONTENTS, contents);
  }
  explicit LogBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Log> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Log>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Log> CreateLog(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t time = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<LogGroup::LogContent>>> contents = 0) {
  LogBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_contents(contents);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Log> CreateLogDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t time = 0,
    const std::vector<::flatbuffers::Offset<LogGroup::LogContent>> *contents = nullptr) {
  auto contents__ = contents ? _fbb.CreateVector<::flatbuffers::Offset<LogGroup::LogContent>>(*contents) : 0;
  return LogGroup::CreateLog(
      _fbb,
      time,
      contents__);
}

inline const LogGroup::LogGroup *GetLogGroup(const void *buf) {
  return ::flatbuffers::GetRoot<LogGroup::LogGroup>(buf);
}

inline const LogGroup::LogGroup *GetSizePrefixedLogGroup(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<LogGroup::LogGroup>(buf);
}

inline LogGroup *GetMutableLogGroup(void *buf) {
  return ::flatbuffers::GetMutableRoot<LogGroup>(buf);
}

inline LogGroup::LogGroup *GetMutableSizePrefixedLogGroup(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<LogGroup::LogGroup>(buf);
}

inline bool VerifyLogGroupBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<LogGroup::LogGroup>(nullptr);
}

inline bool VerifySizePrefixedLogGroupBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<LogGroup::LogGroup>(nullptr);
}

inline void FinishLogGroupBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<LogGroup::LogGroup> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedLogGroupBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<LogGroup::LogGroup> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace LogGroup

#endif  // FLATBUFFERS_GENERATED_LOGGROUP_LOGGROUP_H_
